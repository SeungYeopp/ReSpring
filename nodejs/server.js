const express = require("express");
const http = require("http");
const socketIo = require("socket.io");
const mediasoup = require("mediasoup");

const app = express();
const server = http.createServer(app);
const io = socketIo(server, {
    cors: {
        origin: "*",
        methods: ["GET", "POST"],
    },
});

let worker;
let router;
const transports = {};
const producers = {};
const consumers = {};
const clients = {}; //   roomId Î≥ÑÎ°ú Ïó∞Í≤∞Îêú ÏÇ¨Ïö©Ïûê Í¥ÄÎ¶¨

const createWorker = async () => {
    console.log("üõ†Ô∏è Creating Mediasoup Worker...");
    worker = await mediasoup.createWorker();

    if (!worker) {
        console.error("‚ùå Worker ÏÉùÏÑ± Ïã§Ìå®!");
        return;
    }

    router = await worker.createRouter({
        mediaCodecs: [
            { kind: "audio", mimeType: "audio/opus", clockRate: 48000, channels: 2 },
            { kind: "video", mimeType: "video/VP8", clockRate: 90000 },
        ],
    });

    if (!router) {
        console.error("‚ùå Router ÏÉùÏÑ± Ïã§Ìå®!");
        return;
    }

    console.log("  Mediasoup Worker & Router Created!");
};

io.on("connection", (socket) => {
    console.log("  New client connected:", socket.id);

    socket.on("getRouterRtpCapabilities", (callback) => {
        if (!router) {
            console.error("‚ùå RouterÍ∞Ä ÏïÑÏßÅ ÏÉùÏÑ±ÎêòÏßÄ ÏïäÏùå!");
            return callback({ error: "RouterÍ∞Ä ÏïÑÏßÅ ÏÉùÏÑ±ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§." });
        }
        console.log("üì° Sending Router RTP Capabilities...");
        callback(router.rtpCapabilities);
    });

    socket.on("createTransport", async (callback) => {
        try {
            const transport = await router.createWebRtcTransport({
                listenIps: [{ ip: "0.0.0.0", announcedIp: process.env.MEDIASOUP_ANNOUNCED_IP}],
                enableUdp: true,
                enableTcp: true,
                preferUdp: true,
            });

            transports[transport.id] = transport;

            console.log("  Transport Created:", transport.id);

            callback({
                id: transport.id,
                iceParameters: transport.iceParameters,
                iceCandidates: transport.iceCandidates || [],
                dtlsParameters: transport.dtlsParameters,
            });
        } catch (error) {
            console.error("‚ùå Transport ÏÉùÏÑ± Ïã§Ìå®:", error);
            callback({ error: error.message });
        }
    });

    socket.on(
        "connectTransport",
        async ({ transportId, dtlsParameters }, callback) => {
            const transport = transports[transportId];

            if (!transport) {
                console.error("‚ùå TransportÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå:", transportId);
                return callback({ error: "Transport not found" }); //   ÏóêÎü¨ ÏùëÎãµ Ï∂îÍ∞Ä
            }

            try {
                await transport.connect({ dtlsParameters });
                console.log("  Transport Ïó∞Í≤∞ ÏôÑÎ£å:", transportId);
                callback({ success: true }); //   Ï†ïÏÉÅ ÏùëÎãµ Ï∂îÍ∞Ä
            } catch (error) {
                console.error("‚ùå Transport Ïó∞Í≤∞ Ïã§Ìå®:", error);
                callback({ error: error.message }); //   ÏóêÎü¨ ÏùëÎãµ Ï∂îÍ∞Ä
            }
        }
    );

    socket.on(
        "produce",
        async ({ roomId, transportId, kind, rtpParameters }, callback) => {
            console.log(
                `üì° [produce] ÏöîÏ≤≠: Room ID=${roomId}, Kind=${kind}, Transport=${transportId}`
            );

            if (!roomId) {
                console.error("‚ùå [produce] roomIdÍ∞Ä ÏóÜÏùå!");
                return callback({ error: "roomIdÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§." });
            }

            const transport = transports[transportId];
            if (!transport) {
                console.error("‚ùå [produce] TransportÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå:", transportId);
                return callback({ error: "Transport not found" });
            }

            try {
                const producer = await transport.produce({ kind, rtpParameters });

                const roomKey = String(roomId);
                if (!producers[roomKey]) {
                    producers[roomKey] = [];
                }
                producers[roomKey].push(producer.id);

                console.log(
                    `  [produce] Room ${roomKey}Ïóê Producer Ï∂îÍ∞ÄÎê®:`,
                    producer.id
                );
                callback({ id: producer.id });

                //   ÏÉàÎ°≠Í≤å ÏÉùÏÑ±Îêú ProducerÎ•º Îã§Î•∏ ÏÇ¨Ïö©ÏûêÎì§ÏóêÍ≤å Consume ÏöîÏ≤≠
                const existingClients = clients[roomId] || [];
                const otherUsers = existingClients.filter((id) => id !== socket.id); // Î≥∏Ïù∏ Ï†úÏô∏

                console.log(
                    `üéØ Sending new consume request for producer ${producer.id} to:`,
                    otherUsers
                );
                otherUsers.forEach((userId) => {
                    io.to(userId).emit("triggerConsumeNew", {
                        producerId: producer.id,
                        roomId,
                    });
                });
            } catch (error) {
                console.error("‚ùå [produce] Producer ÏÉùÏÑ± Ïã§Ìå®:", error);
                callback({ error: error.message });
            }
        }
    );

    socket.on("closeProducer", ({ producerId, roomId }) => {
        console.log(`üì¥ Closing Producer ${producerId} in Room ${roomId}`);

        if (!producers[roomId]) return;

        //   Ìï¥Îãπ Producer ÏÇ≠Ï†ú
        producers[roomId] = producers[roomId].filter((id) => id !== producerId);

        if (producers[roomId].length === 0) delete producers[roomId];

        console.log("üì° Updated Producers List:", producers);

        //   Ìï¥Îãπ ProducerÎ•º ÏÜåÎπÑÌïòÎäî Î™®Îì† ÏÇ¨Ïö©ÏûêÏóêÍ≤å Consumer ÏÇ≠Ï†ú ÏöîÏ≤≠
        io.to(roomId).emit("removeConsumer", { producerId });
    });

    socket.on("getProducers", ({ roomId }, callback) => {
        const roomKey = String(roomId);

        if (!roomKey) {
            console.error("‚ùå [getProducers] roomIdÍ∞Ä undefinedÏûÖÎãàÎã§!");
            return callback([]);
        }

        const producerList = producers[roomKey] || [];
        callback(producerList);
    });

    socket.on(
        "consume",
        async ({ roomId, transportId, producerId, rtpCapabilities }, callback) => {
            console.log(
                `üé• [consume] Room ID: ${roomId}, Consumer: ${socket.id}, Producer ID: ${producerId}`
            );

            if (!roomId) {
                console.error("‚ùå ERROR: Room ID is undefined!");
                return callback({ error: "Room ID is required!" });
            }

            const transport = transports[transportId];
            if (!transport) {
                console.error("‚ùå TransportÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏùå:", transportId);
                return callback({ error: "Transport not found" });
            }

            if (!router.canConsume({ producerId, rtpCapabilities })) {
                console.error("‚ùå Cannot consume Producer:", producerId);
                return callback({ error: "Cannot consume Producer" });
            }

            try {
                const consumer = await transport.consume({
                    producerId,
                    rtpCapabilities,
                    paused: false,
                });

                if (!consumers[roomId]) consumers[roomId] = {};
                consumers[roomId][socket.id] = consumer;

                console.log(
                    `  [consume] Room ID: ${roomId}, Consumer ID: ${consumer.id}`
                );

                callback({
                    id: consumer.id,
                    producerId: consumer.producerId,
                    kind: consumer.kind,
                    rtpParameters: consumer.rtpParameters,
                });
            } catch (error) {
                console.error("‚ùå [consume] Consumer ÏÉùÏÑ± Ïã§Ìå®:", error);
                callback({ error: error.message });
            }
        }
    );

    socket.on("joinRoom", ({ roomId }) => {
        if (!clients[roomId]) clients[roomId] = [];
        clients[roomId].push(socket.id);
        console.log(`üë§ Client ${socket.id} joined Room ${roomId}`);
    });

    socket.on("disconnect", () => {
        console.log("‚ùå Client Disconnected:", socket.id);

        //   ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä ÎÇòÍ∞ÄÎ©¥ clients Î¶¨Ïä§Ìä∏ÏóêÏÑú Ï†úÍ±∞
        Object.keys(clients).forEach((roomId) => {
            clients[roomId] = clients[roomId].filter((id) => id !== socket.id);
            if (clients[roomId].length === 0) delete clients[roomId];
        });

        console.log("üì° Updated clients list:", clients);
    });

    socket.on("triggerConsume", ({ roomId }) => {
        console.log(`üì° Received request to trigger consumption in Room ${roomId}`);

        if (!producers[roomId] || producers[roomId].length === 0) {
            console.log(`‚ö†Ô∏è No producers found in Room ${roomId}`);
            return;
        }

        const currentProducers = producers[roomId]; // ÌòÑÏû¨ Î∞©Ïùò producer Î¶¨Ïä§Ìä∏
        const existingClients = clients[roomId] || []; // ÌòÑÏû¨ Î∞©Ïóê ÏûàÎäî Î™®Îì† ÏÇ¨Ïö©Ïûê

        console.log(`üë§ Producers in Room ${roomId}:`, currentProducers);
        console.log(`üë• Clients in Room ${roomId}:`, existingClients);

        //   ÌòÑÏû¨ Ïù¥Î≤§Ìä∏Î•º Î≥¥ÎÇ∏ ÏÇ¨Ïö©ÏûêÎ•º Ï†úÏô∏Ìïú ÏÇ¨Ïö©Ïûê Ï∞æÍ∏∞
        const otherUsers = existingClients.filter((id) => id !== socket.id);

        if (otherUsers.length > 0) {
            console.log(
                `üéØ Sending triggerConsume to other users in Room ${roomId}:`,
                otherUsers
            );
            otherUsers.forEach((userId) => {
                io.to(userId).emit("triggerConsume");
            });
        } else {
            console.warn(
                `‚ö†Ô∏è No other users in Room ${roomId} to send triggerConsume.`
            );
        }
    });
});

server.listen(4000, async () => {
    await createWorker();
    console.log("üöÄ Mediasoup Server running on port 4000");
});
