# 오늘의 학습 정리 (2025년 1월 15일, 수요일)

JPA의 영속성 컨텍스트와 엔티티의 생명주기, 1차 캐시, 변경 감지, 플러시 등의 개념을 이해하고 데이터 관리의 효율성을 학습했습니다. (인프런 강의 수강[자바바 ORM 표준 JPA 프로그래밍])

---

## 목차
1. [JPA와 영속성 컨텍스트 개념](#jpa와-영속성-컨텍스트-개념)
2. [엔티티의 생명주기](#엔티티의-생명주기)
3. [영속성 컨텍스트의 이점](#영속성-컨텍스트의-이점)
4. [플러시와 준영속 상태](#플러시와-준영속-상태)

---

## JPA와 영속성 컨텍스트 개념
- **JPA**: 객체와 관계형 데이터베이스를 매핑하기 위한 Java 표준 API.
- **영속성 컨텍스트**:
  - "엔티티를 영구 저장하는 환경"이라는 뜻.
  - `EntityManager`를 통해 접근 가능.
  - J2SE 환경에서는 엔티티 매니저와 1:1 관계.
  - 스프링과 같은 컨테이너 환경에서는 N:1 관계.

---

## 엔티티의 생명주기
1. **비영속 (new/transient)**:
   - 영속성 컨텍스트와 관계없는 새로운 상태.
   - 예: `new Member()`로 객체 생성.

2. **영속 (managed)**:
   - 영속성 컨텍스트에 관리되는 상태.
   - 예: `em.persist(member)` 호출 후.

3. **준영속 (detached)**:
   - 영속성 컨텍스트에서 분리된 상태.
   - 예: `em.detach(member)`.

4. **삭제 (removed)**:
   - 엔티티가 삭제된 상태.
   - 예: `em.remove(member)`.

---

## 영속성 컨텍스트의 이점
- **1차 캐시**: 동일한 엔티티를 데이터베이스 조회 없이 재사용.
- **동일성 보장**: 같은 엔티티에 대해 동일한 객체 반환.
- **트랜잭션을 지원하는 쓰기 지연**: `commit` 시점까지 SQL 저장.
- **변경 감지 (Dirty Checking)**: 엔티티 변경사항 자동 반영.
- **지연 로딩 (Lazy Loading)**: 실제 데이터 접근 시점까지 데이터 로딩 지연.

---

## 플러시와 준영속 상태
### 플러시
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영.
- 호출 방법:
  1. `em.flush()` 직접 호출.
  2. 트랜잭션 커밋 시 자동 호출.
  3. JPQL 실행 시 자동 호출.

### 준영속 상태
- 영속성 컨텍스트가 제공하는 기능을 사용할 수 없는 상태.
- 상태 전환 방법:
  1. `em.detach(entity)`: 특정 엔티티만 전환.
  2. `em.clear()`: 영속성 컨텍스트 초기화.
  3. `em.close()`: 영속성 컨텍스트 종료.

---

## 결론
JPA의 핵심 개념인 영속성 컨텍스트는 객체와 데이터베이스 간의 매핑을 효율적으로 처리하고, 애플리케이션 개발자가 데이터베이스 작업을 보다 직관적이고 안전하게 수행할 수 있도록 도와줍니다. 엔티티의 생명주기 관리, 1차 캐시, 변경 감지와 같은 기능은 개발 생산성을 크게 향상시킬 수 있는 중요한 요소입니다.

또한, 플러시와 준영속 상태에 대한 이해는 JPA를 활용한 트랜잭션 처리 및 데이터 관리의 신뢰성을 높이는 데 필수적입니다. 이를 통해 데이터 동기화와 애플리케이션의 성능을 최적화할 수 있습니다.

JPA를 깊이 이해하고 활용한다면 효율적이고 유지보수 가능한 코드를 작성할 수 있을 뿐만 아니라, 안정적이고 성능 좋은 애플리케이션을 개발하는 데 기여할 수 있습니다.
