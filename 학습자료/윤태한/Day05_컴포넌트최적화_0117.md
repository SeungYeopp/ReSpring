## 2025년 01월 17일 학습주제

**React에서의 컴포넌트 최적화 기법**

---

### 컴포넌트 최적화란?

#### 최적화의 필요성
- 리액트 애플리케이션에서 렌더링 성능이 중요
- 많은 데이터나 복잡한 UI를 다루는 경우 불필요한 렌더링으로 성능 저하가 발생할 수 있음
- 컴포넌트 최적화는 애플리케이션의 속도와 효율성을 개선하는 데 중요한 역할

#### 최적화 대상
- **불필요한 렌더링**: 상태나 props가 변경되지 않았음에도 컴포넌트가 다시 렌더링되는 경우
- **성능 저하**: 애플리케이션이 복잡해지고 데이터가 많아질수록 렌더링에 시간이 더 걸림

---

### 주요 최적화 기법

1. **React.memo**
   - 컴포넌트가 동일한 props로 렌더링될 때, 이전 결과를 재사용하여 불필요한 렌더링을 방지
   - 고차 컴포넌트(HOC)로 사용되어 성능을 개선

   ```jsx
   const MyComponent = React.memo(function MyComponent(props) {
     return <div>{props.value}</div>;
   });
   ```

2. **useMemo**
   - 계산 비용이 큰 값의 재계산을 방지하기 위해 사용
   - 의존성 배열이 변경될 때만 값이 재계산되도록 최적화

   ```jsx
   const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
   ```

3. **useCallback**
   - 함수가 매번 새로 생성되는 것을 방지하여 자식 컴포넌트에 불필요한 렌더링을 유발하지 않도록 함
   - 함수의 의존성 배열을 사용하여 특정 조건에서만 함수가 새로 생성되도록 최적화

   ```jsx
   const memoizedCallback = useCallback(() => {
     doSomething(a, b);
   }, [a, b]);
   ```

4. **Lazy Loading & Code Splitting**
   - 앱이 초기 로딩 시 모든 코드를 한 번에 불러오지 않고 필요한 시점에 로드
   - React의 `React.lazy()`와 `Suspense`를 사용하여 코드 스플리팅을 구현

   ```jsx
   const MyComponent = React.lazy(() => import('./MyComponent'));
   ```

5. **Intersection Observer**
   - 사용자가 화면을 스크롤할 때, 화면에 보이는 부분만 렌더링하거나 로드하는 방법
   - 성능 최적화 및 메모리 절약에 유용

---

### 장단점

#### 장점
- **성능 향상**: 불필요한 렌더링을 줄이고, 렌더링 성능을 개선
- **사용자 경험 향상**: 화면 렌더링 속도 향상으로 사용자가 느끼는 애플리케이션의 반응성이 빨라짐
- **리소스 절약**: 메모리와 CPU 사용을 줄여서 리소스를 절약

#### 단점
- **복잡성 증가**: 최적화 기법을 과도하게 사용하면 코드가 복잡해질 수 있음
- **불필요한 최적화**: 컴포넌트 최적화가 과도하게 적용되면 오히려 성능이 떨어질 수 있음 (실제 성능 저하가 없는데도 최적화를 적용하면 불필요한 계산이 발생할 수 있음)