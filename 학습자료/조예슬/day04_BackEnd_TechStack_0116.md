# 2025.01.16.THU : BackEnd TechStack

서비스를 기획함에 있어 더 적합한 TechStack을 선택하기 위한 공부.

## 1. 데이터베이스 (DB)
- 관계형 데이터베이스 (RDBMS)
  - MariaDB, MySQL
  - SQL (Structured Query Language)를 사용해 데이터를 관리
- NoSQL
  - MongoDB
  - JSON과 유사한 BSON(Binary JSON) 포맷으로 데이터를 저장

### 🗂️ MariaDB
> MySQL의 fork 버전으로 MySQL과 높은 호환성 유지
- 오픈소스
- MySQL이 Oracle에 인수된 후 커뮤니티의 중심 대안을 제공하기 위해 개발됨
- 특징
  1. MySQL과 거의 동일한 API와 쿼리 문법
  2. 고성능 및 안정성 개선
   - 스토리지 엔진 지원 (Araia, InnoDB, MyISAM, ...)
   - 쿼리 성능 개선 및 고가용성 지원
  3. 오픈소스 정신을 기반으로 FREE



### 🗂️ MongoDB
> 문서 (Document) 기반의 NoSQL 데이터베이스
- 데이터 스키마가 유연하며 JSON과 유사한 BSON 포맷으로 데이터 저장
- 특징
  1. Schemaless 데이터 모델
   - 유연한 데이터 저장 방식으로 사전 정의된 스키마가 필요 없음
  2. 고성능 및 확장성
   - 수평적 확장과 데이터 분산 저장 지원
  3. 복합 데이터 처리
   - 중첩된 데이터 구조를 직관적으로 표현 가능
  4. 배포 용이성
   - 클러스터링 및 분산 데이터 관리에 적합


### ❓ 프로젝트에 채팅 서비스가 있는데 어떤 DB가 적합할까?
> 채팅 애플리케이션의 기능적 요구사항
일반적인 채팅 애플리케이션의 기능적 요구사항은 다음과 같다.
- **메시지 저장**
    - 각 메시지의 내용, 발신자, 수신자, 타임스탬프, 상태(읽음/안읽음) 등을 저장해야 함.
- **빠른 읽기 및 쓰기 성능**
    - 메시지가 실시간으로 처리되어야 하므로 높은 쓰기/읽기 속도가 중요.
- **대화 기록 관리**
    - 메시지 기록을 대화방 단위로 저장하고 조회할 수 있어야 함.
- **확장성**
    - 사용자와 메시지 수가 급격히 증가할 가능성이 있음.
- **다양한 데이터 구조**
    - 첨부파일, 이모지, 메타데이터 등을 유연하게 처리할 수 있어야 함.

> MongoDB의 특징
- 장점
  1. **스키마리스 구조 (Schema-less)**
      - BSON(Binary JSON) 문서 기반으로 데이터를 저장하므로 유연하게 데이터 구조를 변경할 수 있음.
      - 새로운 필드(예: 첨부파일, 메시지 반응)를 추가하는 데 테이블 스키마를 변경할 필요가 없음.
  2. **빠른 쓰기 성능**
      - MongoDB는 쓰기 작업에 최적화되어 있어 실시간 메시지 저장에 적합.
      - 기본적으로 메모리 내 작업을 수행하고 나중에 디스크에 반영.
  3. **수평적 확장**
      - Sharding(샤딩)을 지원하여 데이터를 여러 서버에 분산 저장 가능.
      - 사용자와 메시지 데이터가 폭증하더라도 서버 확장으로 대처 가능.
  4. **복합 데이터 구조**
      - 한 문서에 대화방 정보, 메시지 목록, 사용자 목록 등 복잡한 데이터 구조를 한 번에 저장 가능.
      - 각 채팅방을 문서(Document)로 저장하고, 메시지 리스트를 배열(Array)로 관리 가능.
     - JSON-like 데이터 구조로 채팅 메시지, 첨부파일, 메타데이터를 한 곳에 저장 가능.
  5. **쿼리 유연성**
      - MongoDB의 강력한 쿼리 언어를 사용해 특정 대화방, 사용자, 시간대에 대한 메시지 검색이 가능.

- **단점**

  1. **관계형 데이터 처리의 한계**
      - 채팅 애플리케이션에서 대규모 관계형 데이터를 관리(예: 그룹 채팅의 멤버 관리)하는 데는 RDBMS만큼 강력하지 않을 수 있음.
  2. **트랜잭션 처리의 복잡성**
      - MongoDB는 단일 문서 트랜잭션에는 강하지만, 다중 문서 트랜잭션에서는 복잡성이 증가.
      - 예를 들어, 메시지와 읽음 상태를 별도의 컬렉션에 저장한다면 트랜잭션이 필요할 수 있음.


> 그러나 우리 서비스의 경우, **RDBMS(MySQL, MariaDB)**가 더 적합할 가능성도 있다.
현재 기획하고 있는 퇴직자의 제2의 인생을 응원하는 '다시, 봄 (Re:Spring)' 서비스는 1:1 채팅만을 목적으로 하고 대규모 채팅이나 동시성 문제가 크지 않다.

1. 채팅 메시지 저장 및 조회
   - 채팅 메시지를 저장하고, 특정 사용자 간의 대화를 조회할 수 있어야 함.
   - 과거 대화 기록을 간단하게 불러오는 기능 필요.
2. 데이터 구조의 안정성
   - 채팅 데이터의 구조가 크게 변하지 않음.
   - 메시지에 새로운 필드(첨부파일, 읽음 상태 등)가 추가될 가능성 낮음.
3. 소규모 사용자 기반
   - 대규모 확장성 필요 없음. 단일 서버에서 운영 가능.
4. 간단한 트랜잭션 처리
   - 메시지 저장 및 읽음 상태 업데이트 같은 간단한 작업 필요.

=> 충분한 검토 필요해보임

<br>

## 2. ElasticSearch
> 분산형 검색 및 분석 엔진
- JSON 문서 기반으로 동작하며, 대규모 데이터를 실시간으로 검색하고 분석하는 데 사용
- **Elasticsearch + Logstash + Kibana(ELK Stack)**으로 함께 사용하면 강력한 데이터 처리와 시각화 가능.
- 특징
   1. 빠른 검색
      - 역색인(Inverted Index) 기반으로 고속 텍스트 검색.
   2. 분산 구조
      - 클러스터링 및 수평적 확장 지원.
   3. RESTful API
      - HTTP 기반 API로 데이터 CRUD 및 검색 가능.
   4. 실시간 분석
      - 대규모 데이터 집합에서 실시간 집계 및 필터링.

### ElasticSearch를 프로젝트에 적용하기

1. 검색 엔진 구현
- 전자상거래 사이트에서 제품 검색, 필터링.
- 블로그 플랫폼에서 텍스트 기반 콘텐츠 검색.
2. 로그 분석 및 모니터링
- 서버 로그나 애플리케이션 로그를 실시간 분석.
- ELK 스택(Logstash로 로그 수집, Kibana로 시각화).
3. 추천 시스템
- 사용자의 검색 기록을 기반으로 추천.
4. 대규모 데이터 집계
- 실시간 데이터 집계 및 분석 대시보드 구현.

<br>

> **ElasticSearch 활용 절차**

1. **데이터 모델 설계**
    - 검색에 최적화된 JSON 문서 형식으로 데이터 구성.
2. **데이터 인덱싱**
    - RESTful API를 사용해 데이터를 ElasticSearch에 저장.
    
    ```bash
    curl -X POST "http://localhost:9200/products/_doc/1" -H 'Content-Type: application/json' -d'
    {
      "name": "Smartphone",
      "brand": "BrandX",
      "price": 799
    }'
    
    ```
    
3. **검색 및 필터링 구현**
    - 쿼리 DSL(Query Domain-Specific Language)을 사용하여 복잡한 검색 실행.
    
    ```bash
    curl -X GET "http://localhost:9200/products/_search" -H 'Content-Type: application/json' -d'
    {
      "query": {
        "match": {
          "name": "Smartphone"
        }
      }
    }'
    
    ```

## 3. Infra
> AWS EC2, S3?

### AWS EC2 (Elastic Compute Cloud)
- 클라우드에서 가상 서버를 생성하고 실행할 수 있는 컴퓨팅 서비스
- 사용자는 물리적인 서버를 구매하거나 관리할 필요 없이 원하는 사양의 가상 서버를 생성해 애플리케이션을 호스팅하거나 실행할 수 있다.
- 주요 특징
  1. **온디맨드 컴퓨팅**
     - 필요할 때 서버를 생성하고, 사용한 만큼 비용을 지불.
  2. **유연한 인스턴스 설정**
      - CPU, 메모리, 스토리지 등 다양한 사양의 인스턴스를 제공.
  3. **확장성**
      - 트래픽 증가 시 더 많은 서버를 추가(스케일 아웃)하거나 서버 크기를 증가(스케일 업).
  4. **다양한 운영 체제 지원**
      - Windows, Linux 등 다양한 운영 체제를 선택 가능.

- 주요 사용 사례
  1. **웹 애플리케이션 호스팅**
      - Node.js, Spring Boot, Django와 같은 백엔드 애플리케이션을 실행.
  2. **배치 처리**
      - 데이터 분석, 로그 처리, 이미지/동영상 변환 등.
  3. **데이터베이스 서버**
      - RDS(MariaDB, MySQL 등) 대신 EC2에 직접 데이터베이스 설치 및 운영.
  4. **마이크로서비스 아키텍처**
      - 다양한 마이크로서비스를 독립적인 EC2 인스턴스에서 운영.

### AWS S3 (Simple Storage Service)
- 객체 스토리지 서비스로, 데이터를 파일(객체) 형태로 저장하며, 대규모 데이터를 안전하고 경제적으로 관리할 수 있다.
- 주요 특징
  1. **객체 기반 저장소**
      - 파일과 해당 메타데이터를 함께 저장. 디렉토리 계층 구조가 아닌 "버킷"을 사용.
      - 이미지, 동영상, 문서와 같은 비정형 데이터를 저장하는 데 최적화.
      - 파일 이름(Key)으로 개별 객체를 식별하고 관리.
  2. **무제한 스토리지**
      - 저장 가능한 데이터 크기에 제한이 없음.
  3. **높은 내구성 및 가용성**
      - 99.999999999%의 내구성을 제공하며, 데이터 손실 위험이 거의 없음.
  4. **다양한 저장 클래스**
      - 데이터 접근 빈도에 따라 비용 효율적인 저장 클래스 선택 가능 (예: Standard, Glacier).

- 이미지를 저장하는 데 적합하며, 실제로 많은 애플리케이션에서 이미지나 파일 저장소로 사용된다.
  - CDN (Content Delivery Network) 통합
    - S3와 AWS CloudFront를 함께 사용하면, 전 세계적으로 빠른 이미지 전송이 가능.
  - 보안
    - 접근 제어 정책, 암호화 기능(AES-256, KMS) 제공으로 안전한 이미지 저장 가능.
  - 예시
    - 사용자 프로필 이미지, 게시물 첨부 이미지 저장.
    - 상품 이미지, 썸네일 저장.
    - 이미지, 동영상, 문서 등의 데이터 백업.

<br>

> 예상 파이프라인
- 사용자가 이미지를 업로드하면 EC2 서버에서 이를 처리하고 S3에 저장.
- S3에 저장된 이미지는 URL로 제공되어 다른 서비스에서 사용 가능.
- 웹앱 배포 시, 정적 파일(HTML, CSS, JS 등)은 S3에 저장하여 빠르게 제공. 동적 데이터 처리는 EC2에서 실행


## 4. Webhook
> Webhook은 애플리케이션 간 실시간 통신을 가능하게 하는 메커니즘으로, 특정 이벤트가 발생했을 때 이를 즉시 다른 서비스나 애플리케이션에 알림(HTTP 요청) 형태로 전송하는 방식

- 주로 HTTP POST 요청을 통해 데이터를 전송.
- 수동으로 데이터를 요청하는 방식(Pull)과 달리, 이벤트가 발생하면 자동으로 데이터를 전송(Push).
- 예시
  - 결제 시스템: 결제 성공/실패 알림을 서버에 전달 -> 후속 작업 진행 (PayPal)
  - 알림 시스템: 특정 이벤트 발생 시 알림을 채널로 전송 (Slack, Discord)
  - 전자상거래 플랫폼: 주문 생성, 취소, 배송 상태 변경 등을 알림
  - 소셜 미디어: API에서 Webhook을 통해 실시간으로 데이터 전송
- 장점
  - **실시간 업데이트**
      - 이벤트 발생과 동시에 데이터를 전송하므로 지연 시간이 없음.
  - **효율성**
      - 필요할 때만 데이터를 전송하므로 서버 자원과 네트워크 비용 절약.
  - **간단한 설계**
      - HTTP 요청만 처리하면 되므로 비교적 간단하게 구현 가능.
- 단점
  - **수신자 가용성 의존**
      - 수신자가 다운되거나 접근 불가능하면 데이터 전달 실패.
  - **보안 문제**
      - Webhook URL이 노출되면 악의적인 요청이 발생할 가능성.
      - **HMAC**과 같은 서명을 활용해 요청의 진위를 검증해야 함.
  - **디버깅 어려움**
      - 요청을 실시간으로 처리하므로 디버깅이 어려울 수 있음.

### Webhook의 작동원리
- 발신자(Sender)
   - 이벤트를 감지하고 Webhook을 트리거(trigger)합니다.
   - 예: GitHub에서 푸시(push) 이벤트 발생.
- 수신자(Receiver)
   - 발신자로부터 HTTP POST 요청을 받고, 데이터를 처리합니다.
   - 예: 슬랙(Slack)에서 알림 메시지 수신.
- 데이터 포맷
   - 일반적으로 JSON 형식으로 데이터를 전송.

1. **설정**
    - 수신자는 Webhook을 사용할 URL(엔드포인트)을 발신자에게 제공.
2. **이벤트 발생**
    - 발신자에서 특정 이벤트(예: 데이터 변경, 상태 업데이트)가 발생.
3. **HTTP 요청 전송**
    - 발신자가 사전에 설정된 URL로 HTTP POST 요청과 데이터를 전송.
4. **수신자에서 처리**
    - 수신자는 요청을 받아 필요한 작업을 수행.

<br>

> **Webhook과 Polling 비교**

| **항목**        | **Webhook**                           | **Polling**                      |
| --------------- | ------------------------------------- | -------------------------------- |
| **작동 방식**   | 이벤트 발생 시 실시간으로 데이터 전송 | 주기적으로 데이터를 요청         |
| **효율성**      | 서버 자원 효율적 사용                 | 불필요한 요청으로 서버 부하 가능 |
| **응답 시간**   | 실시간                                | 요청 주기에 따라 지연 발생 가능  |
| **구현 복잡도** | 발신자와 수신자 간 설정 필요          | 상대적으로 간단                  |


